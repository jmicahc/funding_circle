(ns funding_circle.prime-algorithms
  (:require [clojure.data.priority-map :refer [priority-map]]
            [clojure.pprint :refer [print-table]]))

;; Brute force prime generation algorithm works by testing if
;; the nth number has no lesser numbers that divide it.
(def brute-force
  (cons 2 (filter (fn [n]
                    (loop [i 2]
                      (if (= i n) n
                          (when (pos? (mod n i))
                            (recur (inc i))))))
                  (iterate inc 3))))


(take 10 brute-force)

;; Trial division algorithms work by testing whether the nth number
;; can be written as a composite of previous primes. This algorithm
;; eagerly builds a vector of n primes. 
(defn eager-trial-division
  ([n]
   (loop [prev [2] i 1]
     (if (== i n) prev
       (recur (->> (iterate inc (peek prev))
                   (filter (fn [n] (not-any? zero? (map #(rem n %) prev))))
                   first
                   (conj prev))
              (inc i))))))

;; The above can easily be implemented lazily by recursively
;; building up a filter that removes all subsequent numbers 
;; that are divisible by the nth prime.
(def lazy-trial-division
  (letfn [(step [[prime & xs]]
            (lazy-seq (cons prime (step (filter #(pos? (mod % prime)) xs)))))]
    (step (iterate inc 2))))


;; We can reimplement the lazy trial division algorithm above using 
;; transducers in the hopes of eliminating the overhead of realizing 
;; intermediate filter results. Turns out this is actually much slower.
(def lazy-trial-division-xf
  (letfn [(step [n f]
            (let [[p n] (sequence f (iterate inc n))]
              (lazy-seq (cons p (step n (comp f (filter #(pos? (mod % p)))))))))]
    (cons 2 (step 3 (filter #(pos? (mod % 2)))))))


;; By noting that any x > sqrt(n) cannot divide n, we can achieve a substantial
;; practical speedup of the lazy trial division algorithm. This algorithm is the 
;; same as above, except it only takes primes from previous primes that are 
;; less than the square root of the nth prime. Note that lazy sequences cache,
;; so we are not recomputing primes on recursive calls.
(def optimized-trial-division
  (lazy-seq
    (letfn [(candidate-factors [x]
              (take-while (fn [p] (<= (* p p) x)) optimized-trial-division))
            (prime? [x]
              (not-any? zero? (map #(mod x %) (candidate-factors x))))]
      (cons 2 (filter prime? (iterate inc 3))))))


;; Here is an implementation of segmented Sieve algorithm base on
;; segmented sieve algorithm described at: 
;; https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes
;; with the segment size equal to square root of n.
;; This algorithm produces all primes <= n. Unfortunately,
;; there doesn't seem to be an elegant way to produce the first
;; n primes with this algoirhtm. One would want to estimate the
;; number of primes, P(n), as a function of n. The prime number theorem
;; could work here (P(n) ~ nlog(n)), but the erorr is large for small n, making
;; it tricky to described a good closed formula for (over) estimating P(n).

;; The advantage of the segmented Sieve Algorithm over tranditional Seive is 
;; that it reduces the space complexity. It works by first computing the first 
;; primes < sqrt(n) with a typical sieve algorithm. The Sieve algorithm, by the way,
;; works by "crossing off" all multiples of n greater than n for all n from 2 to sqrt(n).
;; Everything not crossed off is then a prime. After initial sieving, segmented sieve 
;; adds all those primes in x > sqrt(n) + 1 in sqrt(n)-sized chucks which are not 
;; divisible by any of the computed primes. Note that for any product, x * y = n,
;; max(x, y) <= sqrt(n), so any composite less than n is divisible by some 
;; number, x <= sqrt(n).

;; Note that segmented sieve does not translate very idomatically to Clojure. 
;; Further, this algorithm uses seqs, which are amazing slow compared to 
;; loop-based iterations. This is included merely as an example of
;; segmented Sieve.
(defn segmented-sieve
  ([n]
   (letfn [(sieve [n]
             (let [a (boolean-array n true)]
               (aset a 0 false)
               (aset a 1 false)
               (doseq [i (range 2 (Math/sqrt n))
                       :when (aget a i)
                       j (iterate (partial + i) (* i i))
                       :while (< j n)]
                 (aset a j false))
               (loop [ret (transient []) i 0]
                 (if (== i n) (persistent! ret)
                     (recur (if (aget a i) (conj! ret i) ret)
                            (inc i))))))
           (segment [n]
             (let [segment-size (.intValue (Math/ceil (Math/sqrt n)))
                   primes (sieve segment-size)
                   segments (partition segment-size segment-size []
                                       (range (inc segment-size) n))]
               (into primes
                     (for [segment segments
                           n segment
                           :when (not-any? zero? (map #(mod n %) primes))]
                       n))))]
     (segment n))))

;; Unfortunately Cloure's priority map evaluates keys when associated,
;; so we wrap a lazy sequence in a cell to prevent eager evaluation.
(deftype Cell [value]
  clojure.lang.IDeref
  (deref [this] value))


;; This is a lazy, incremental version of the Sieve of Eratosthenes 
;; algorithm implemented using a priority map. This algorithm works 
;; by storing lazy sequences of the multiples of the nth prime, p, in
;; a priority map with priority given by the composite p^2.  Using the 
;; priority queue, we  maintain the property that the next composite is the first


;; If the next composite is less than x, then x is 
(defn incremental-sieve
  ([[x & xs]]
   (letfn [(insert-prime [prime xs table]
             (assoc table (Cell. (map (partial * prime) xs)) (* prime prime)))
           (sieve [[x & xs] table]
             (letfn [(adjust [table]
                       (let [[cell yy] (peek table)
                             [y & ys] @cell]
                         (if (<= yy x)
                           (recur (assoc (pop table) (Cell. ys) y))
                           table)))]
               (when x
                 (let [next-composite (second (peek table))]
                   (if (<= next-composite x) (recur xs (adjust table))
                     (lazy-seq (cons x (sieve xs (insert-prime x xs table)))))))))]
     (when x (lazy-seq (cons x (sieve xs (insert-prime x xs (priority-map)))))))))


;; Produce an infinite, increasing sequence of numbers that excludes
;; multiples of the wheel primes.
(defn spin [[x & xs] n] (lazy-seq (cons n (spin xs (+ n x)))))


(def wheel2 (lazy-seq (cons 2 wheel2)))


(def wheel23 (lazy-seq (cons 2 (cons 4 wheel23))))


(def wheel235
  (lazy-seq (cons 4 (cons 2 (cons 4 (cons 2 (cons 4 (cons 6 (cons 2 (cons 6 wheel235))))))))))


(def wheel2357 (cycle (list 2 4 2 4 6 2 6 4 2 4 6 6 2 6
                            4 2 6 4 6 8 4 2 4 2 4 8 6 4
                            6 2 4 6 2 6 6 4 2 4 6 2 6 4
                            2 4 2 10 2 10)))


(def wheel2-primes (lazy-seq (list* 2 (incremental-sieve (spin wheel2 3)))))


(def wheel23-primes (lazy-seq (list* 2 3 (incremental-sieve (spin wheel23 5)))))


(def wheel235-primes (lazy-seq (list* 2 3 5 (incremental-sieve (spin wheel235 7)))))


(def wheel2357-primes (lazy-seq (list* 2 3 5 7 (incremental-sieve (spin wheel2357 11)))))


(vec (take 10 wheel2357-primes))

